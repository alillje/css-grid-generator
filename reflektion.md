# Reflektion
*1DV610*<br>
**Andreas Lillje**


Jag har försökt fokusera på att skriva så korta funktioner/metoder som möjligt och har velat följa regeln enligt kapitel 3 i boken att de ska vara så korta som möjligt, och bara göra en sak. 

## **Namngivning**
| Namn & Förklaring     | Reflektion |
| --------- |:----:|
| **GridGenerator** <br>Huvudnamn på Klassen| **Avoid Disinformation**<br> Här tycker jag inte att jag följer reglerna för avoid disinformation. Namnet GridGenerator, antyder att klassen har som enda uppgift att generera en grid.<br>Vilket delvis stämmer, men klassen har fler uppgifter än så, i form av att manipulera HTML element.<br>Mitt mål är därför att hitta ett bättre namn på huvudklassen innan inlämning.<br><br>**Class Names**<br>I det här fallet följs reglerna för hur en klass ska döpas. Klassnamnet är ett substantiv och inte ett verb.<br>**Pick one word per concept*<br>Samtliga metoder i denna huvudklass följer samma mönster och använder samma verb, get och set.Här blandas inte get med exempelvis fetch, eller retrieve. <br>Detsamma gäller för verbet set. | 
| **getGridCss( { grid } )**<br>Tar in data i form av ett Javascript-objekt och returnerar en template för en grid-layout i form av CSS-kod. | **Use intention revealing names**<br>Här tycker jag att jag lyckas med att ge metoden ett ett beskrivande namn. Min uppfattning är att metodnamnet en beskrivning av vad metoden faktiskt gör.<br><br>**Method Names**<br>Har följt regeln för att metodnamn ska vara verb, eller ha verb phrase names, för de publika metoderna och använd get som ett prefix i det här fallet.
 | **getPositionCss( { grid } )**<br>Tar in data i form av ett Javascript-objekt och returnerar ett elements position i en grid-layout i form av CSS-kod. | **Use intention revealing names**<br>Likt gridCss() tycker jag har lyckats med detta metodnamn, dock inte lika bra. <br>Detta beror på att jag inte tycker att denna metod beskriver vad den gör lika bra.<br><br>**Use pronounceable names**<br>Om jag hade velat ha ett mer deskriptivt metodnamn, hade jag kunnat döpa den till exempelvis *getCssTemplateForPositionInCssGridLayout()*.<br>Här har jag alltså gjort en kompromiss och valt ett namn som är kortare och lättare att uttala och på så sätt kompromissat bort en del av metodens intention.<br><br>**Method Names**<br>Har följt regeln för att metodnamn ska vara verb, eller ha verb phrase names, för de publika metoderna och använd get som ett prefix i det här fallet. |
 | **setGrid({ grid }, htmElement)**<br>Tar in data i form av ett Javascript objekt med instruktioner för hur layouten ska se ut. Tar in en ett HTML-elements identifierare och sätter CSS-egenskaper i form av en layout på HTML-elementet. | **Don’t use misinformation**<br>Under denna reflektion inser jag att jag döpt det andra argumentet till htmlElement, vilket är missvisande. Det är html-elementets identifierare som tas som argument och detta kommer att åtgärdas till inlämning. <br><br>**Method Names**<br>Har följt regeln för att metodnamn ska vara verb, eller ha verb phrase names, för de publika metoderna och använd get som ett prefix i det här fallet.


## **Funktioner**
| Metodnamn  | Antal Rader | Reflektion |
| ---------- | ----------- |:----:|
| **GridGenerator.setPosition({ grid }, htmlElement)** | 15 | **Small**<br>Jag anser att funktionen är lite för lång och är av uppfattningen att man skulle kunna bryta ut mer för att skriva metoden kortare<br><br>**Dyadic Functions**<br> Här är min känsla att det var nödvändigt att ta in två argument. Eftersom att elementet ska positioneras i ett rutnät behöver vi ha start och slutpositioner. Detta tas upp som ett exempel i boken för att använda sig av 2 argument. För att kunna veta vilket element som ska manipuleras behöver vi även detta som ett argument. När man tittar på koden, kan det se ut som att det är fler än 2 argument, men det är alltså ett objekt och en sträng som tas in. Objektet "destrueras" och extraherar dess egenskaper direkt i argumentfältet.<br><br>**Argument Objects**<br>Här tar metoden in ett objekt med egenskaper som argument, istället för att ta in varje egenskap som ett eget argument, och minskar då antalet argument.<br><br>**Extract Try/Catch Blocks**<br>Litteraturen föreslår att man bryter ut try..catch blocken i egna funktioner. På sätt och vis tycker jag att jag gör det här, då metoden kallar på en annan metod som sköter valideringen. Problemet jag ser här är att denna metod även bygger en sträng och returnerar. Här kan man tänka sig att man bryter ut till ytterliggare en metod som bara har som uppgift att anropa validerings-metoden.  ||
| **GridGenerator.setGrid({ grid }, htmlElement)** | 14 | **Dyadic Functions**<br> Här är min känsla att det var nödvändigt att ta in två argument. Eftersom att det behövs antal och längd/bredd på rader och kolumner behöver detta anges för att kunna "rita" ett rutnät. För att kunna veta vilket element som ska manipuleras behöver vi även detta som ett argument. När man tittar på koden, kan det se ut som att det är fler än 2 argument, men det är alltså ett objekt och en sträng som tas in. Objektet "destrueras" och extraherar dess egenskaper direkt i argumentfältet.<br><br>**Argument Objects**<br>Här tar metoden in ett objekt med egenskaper som argument, istället för att ta in varje egenskap som ett eget argument, och minskar då antalet argument.<br><br>**Extract Try/Catch Blocks**<br>Litteraturen föreslår att man bryter ut try..catch blocken i egna funktioner. På sätt och vis tycker jag att jag gör det här, då metoden kallar på en annan metod som sköter valideringen. Problemet jag ser här är att denna metod även bygger en sträng och returnerar. Här kan man tänka sig att man bryter ut till ytterliggare en metod som bara har som uppgift att anropa validerings-metoden.  |
| **RowColumnValidator.validate(columnsOrRows)** | 13 | <br><br>**Prefer Exceptions to Returning Error Codes**<br>Metoden kastar ett *Error* istället för ett *Exception*. Här skulle man kunna göra om typen av objekt som metoden kastar.
| **GridValidator.validatePositions(positions)** | 10 | **Do one thing**<br>Metoden gör dessvärre flera saker och följer inte den här regeln. Metoden utvärderar alla egenskaper i objektet som den tar in som argument,tittar om det är ett nummer, sedan tittar metoden om värdena i objektet är *undefined* för att slutligen returnera.<br>Här är målet att bryta ut till ytterliggare en funktion för att få en bättre *separation of concerns* <br><br> |
| **RowColumnValidator.isSizingKeyword(cssValue)** | 5 | **Do one thing**<br>Metoden gör endast en sak, dvs. Tittar på ett värde och avgöra om det är en korrekt "sizing-keyword"<br><br>**Small**<br>Funktionen är kort, den kan inte skrivas mycket kortare. Eventuellt med en tenary operator. Jag tycker dock att det i det här fallet blir lättare och tydligare att läsa med if-satser.<br><br>**Use descriptive names**<br>Jag tycker att det framgår tydligt vad som är metodens uppgift.<br><br>**Common Monadic Forms**<br>Här tas endast ett argument in och läses av innan funktionen returnerar. |
